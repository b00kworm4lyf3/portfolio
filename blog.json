{
  "posts": [
    {
      "id": "CSCI4239-2025-01-13-Homework-01",
      "title": "CSCI4239 Homework 1: NDC to RGB Shader",
      "date": "2025-01-13",
      "tags": {
        "Course": ["CSCI4239", "Advanced Computer Graphics"],
        "Topic": ["OpenGL", "GLSL Shaders"]
      },
      "content": [
        {
          "type": "section",
          "heading": "Goals",
          "note": "Written 01-13",
          "blocks": [
            {
              "type": "text",
              "text": "I want to make sure I understand the basic concepts first so will be initially working on making it look/work similarly to what we were shown in class. Once I get that working though I want to try to do a quick implementation of my falling stars particles that I made with P5.js last year."
            }
          ]
        },
        {
          "type": "section",
          "heading": "Reflection",
          "note": "Written 1-14/1-15",
          "blocks": [
            {
              "type": "text",
              "text": "The basic NDC to RGB shader was pretty straightforward, especially after I gave up trying to do it completely in the frag shader. I know it can be done using just the frag shader, but realized after fiddling for a bit that I was just reverse engineering something that the vertex shader already did. Once I got the trivial shader working I wanted to add in my stars, for which I repurposed the particle system I wrote for my final project in CSCI4229 last semester."
            },
            {
              "type": "video",
              "src": "img/csci4239/hw1.mp4",
              "caption": "Star particle system with NDC to RGB shader applied"
            },
            {
              "type": "text",
              "text": "Getting the NDC to RGB color swap to work was simple, as I just had to change the original color assignment to what I had done for the NDC to RGB shader, but calculating a star shape for my point sprites was an absolute brainteaser! I ended up reading some blogs and The Book of Shaders to figure out how to do it and got a little pinwheel looking thing before I decided to get some help from Claude. I asked it to not give me the answer directly but to give me feedback on my thinking process, and that helped me realize I was forgetting to mix between the inner and outer radius of the star."
            },
            {
              "type": "code",
              "language": "GLSL",
              "code":"vec2 p = gl_PointCoord*2 - 1; //-1 - 1 (xy plane)\nfloat angle = atan(p.y, p.x);\nfloat dist = length(p); //from center\n\nfloat slice = mod(angle,TAU/5)/(TAU/5); //normalized angle in slice\nfloat r = mix(inR, outR, abs(slice*2 -1));\nfloat alpha = 1 - step( r, dist);\nif(alpha < 0.01) discard; //cutout\n\ngl_FragColor = vec4(colour, alpha);"
            },
            {
              "type": "text",
              "text": "I'm pretty happy with how this turned out! I would like to add some twinkling and rotation for the next pass I take on the stars, but I'm happy I decided to add a little extra to this assignment."
            },
            {
              "type": "link",
              "url": "https://github.com/b00kworm4lyf3/CSCI4239-hw1-NDC2RGB",
              "text": "Link to GitHub Repo"
            }
          ]
        }
      ],
      "assignmentDetails": "Create a program that displays a scene in 3D that can be viewed from any direction under user control. Example 1 would be a good starting point.\n\nThe color of every vertex in every object should be set using a shader such that the coordinates of the vertex in Normalized Device Coordinates ([-1,+1] in x,y,z) determines the color of the vertex using a linear mapping in RGB space [0-1].\n\nYour program must work in both orthogonal and perspective, so NDC space starts as 4D homogeneous coordinates and w will not be 1.\n\nThis is a trivial shader, and the vertex and fragment shader should each be only one or two lines.  So make an effort of making this as elegant as you can. Consider this Shader Golf.\n\nWhat to submit:\n1) One ZIP archive containing all files you are submitting;\n\t2) Source code, makefile and any data files I need;\n\t3) README with brief instructions on how to use the program;\n\t4) Time it took you to complete the assignment.\n\nDo a \"make clean\" before creating the ZIP file to clean out intermediate files.\n\nMake sure your program unzips in the current folder.\n\nYou may use the CSCIx5239 library, but make sure that you know what each function from that library that you use is doing."
    },
    {
      "id": "CSCI4239-2025-01-18-Homework-02",
      "title": "CSCI4239 Homework 2: Procedural Textures",
      "date": "2025-01-18",
      "tags": {
        "Course": ["CSCI4239", "Advanced Computer Graphics"],
        "Topic": ["OpenGL", "GLSL Shaders"]
      },
      "content": [
        {
          "type": "section",
          "heading": "Goals",
          "note": "Written 01-18",
          "blocks": [
            {
              "type": "text",
              "text": "I would like to make a material that reacts when the user mouses over it - like a frosty window that gets more transparent when moused over, or like drawing in the steam on a mirror. I gotta get the mouse-over working first and then I can work on making it pretty."
            },
            {
              "type": "text",
              "text": "I also need to do some research on making a believable glass material, which is hopefully not too tough to do! I'm going to start with the example program this week so that I can make sure I'm getting the lighting right for this first time doing it using shaders, but once I have that working I'll probably see if I can implement the lighting into my homework from last week so that I can get some practice doing it myself."
            }
          ]
        },
        {
          "type": "section",
          "heading": "Reflection",
          "note": "Written 01-21",
          "blocks":[
            {
              "type": "text",
              "text": "My original goal with this homework was to make a foggy glass shader that you could clear by clicking and dragging. After doing a bit of research though I determined that doing something as realistic as I wanted fell far outside anything we've covered so far and also probably wouldn't count as a texture so much as an effect. So I pared the idea down a bit and decided to start with making something glass-like (the basic transparent fresnel shader) and then build textures off that."
            },
            {
              "type": "video",
              "src": "img/csci4239/hw2_fresnel.mp4",
              "caption": "Basic glowy fresnel effect"
            },
            {
              "type": "text",
              "text": "I read about how to implement fresnel and Schlick's approximation on graphicscompendium.com and a few random blogs, though my first implementation didn't work with transparency because I had used max(dot(N, V), 0.0) instead of abs(dot(N,V)) and I was getting an overwhelming glow from all the back faces! Once I fixed that I decided I wanted to try to keep with my foggy/clear glass idea but lower fidelity then I had originally planned. I copied my basic fresnel and made a new one that used a noise texture generated from noise.c to look foggy and then passed in xy mouse coords when the mouse is clicked. Using those coords I calculated a small area to clear the noise from n_n I spent a while tweaking all the params to make it look perfect and I'm pretty happy with it! I think it could definitely be improved, I would love to build it out more to be able to be drawn on and then have the fog slowly come back in."
            },
            {
              "type":"video",
              "src": "img/csci4239/hw2_foggy.mp4",
              "caption": "Demonstration of foggy glass texture with proportional zoom"
            },
            {
              "type": "text",
              "text": "Finally, I wanted to mess with my star particles from last week seeing as they were calculated almost completely in the frag shader and I thought it would be fun to reimplement them as a texture. I added some animation to them so I could try that out and built a bit on the fresnel effect to also have the edges lit because they looked kinda empty just blue."
            },
            {
              "type": "video",
              "src": "img/csci4239/hw2_animated.mp4",
              "caption": "Animated star texture derived from homework 1"
            },
            {
              "type": "link",
              "url": "https://github.com/b00kworm4lyf3/CSCI4239-hw2-procedTex",
              "text": "Link to GitHub Repo"
            }
          ]
        }
      ],
      "assignmentDetails": "Create a program that allows a scene to be viewed in 3D from any direction under user control.\n\nThe objects in the scene should be colored using a procedural texture shader. You may not use the wave, brick or mandlebrot shaders shown in class.  If you use a shader from the text or the web, you should improve it.\n\nThis is your first real shader and is an opportunity to explore a few of the features of GLSL.  Appendix C in the text describes the builtin functions which provides useful manipulations.\n\nYour scene should be lit.  You may reuse the phong() function from the Example 2 vertex shader, but improvements are always encouraged.\n\nThe resulting shader may be only a few lines long, so make sure you can justify and explain every line\n\nWhat to submit:\n1) One ZIP archive containing all files you are submitting;\n2) Source code, makefile and any data files I need;\n3) README with brief instructions on how to use the program;\n4) Time it took you to complete the assignment.\n\nRemember to clean up your code and use good software engineering practices.  If you start with my example code, clean out the example shaders.\n\nIn your shader, make sure you can justify and explain every statement."
    },
    {
      "id": "ATLS3300-2025-01-26-Lab-01",
      "title": "ATLS3300 Lab 1: All Wired Up",
      "date": "2025-01-26",
      "tags": {
        "Course": ["ATLS3300", "Object"],
        "Topic": ["Circuits"]
      },
      "content": [
        {
          "type": "section",
          "heading": "Description",
          "blocks": [
            {
              "type": "text",
              "text": "This lab is an introduction to electronics and simple circuits. Using components from the <a href=\"https://www.amazon.com/ELEGOO-Project-Tutorial-Controller-Projects/dp/B01D8KOZF4\" target=\"_blank\" rel=\"noopener noreferrer\">ELEGOO UNO Starter Kit</a>, we will build a simple circuit that lights up an LED when a button is pressed."
            },
            {
              "type": "text",
              "text": "Materials Used:\n- Multimeter\n- Power Supply Module\n- Momentary Push Button\n- 830 Tie-Points Breadboard\n- Jumper Wires\n- 9V Battery with Snap-On Connector\n- Resistors\n- LEDs"
            }
          ]
        },
        {
          "type": "section",
          "heading": "Part 1: Setting Up Power",
          "blocks": [
            {
              "type": "text",
              "text": "We set up the power for our circuit using a 9V battery with a snap-on connector. The connector allows us to hook our battery up to the power supply module using a barrel jack input. The power supply module is a voltage regulator that can convert the 9V to 5V and 3.3V, this allows us to power our LED using lower voltage through the power supply output pins. The power supply connects to the breadboard and once we've connected the battery we can measure the voltage coming through each side of the power supply in order to double check that it is properly converting from 9V. We had to get a few extra hands involved to measure this properly and also take a picture, it was a pretty fiddly process!"
            },
            {
              "type": "images",
              "layout": "side-by-side",
              "images": [
                {
                  "src": "img/atls3300/lab01_3v_measure.JPG",
                  "caption": "Measuring the 3.3V side with a multimeter"
                },
                {
                  "src": "img/atls3300/lab01_5v_measure.JPG",
                  "caption": "Measuring the 5V side with a multimeter"
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "heading": "Part 2: (Not) Blowing Up an LED",
          "blocks": [
            {
              "type": "text",
              "text": "Connecting the LED directly to 5V or 3.3V without a resistor would likely blow out the LED due to too much current flowing through it. In order to prevent this we calculate what value resistor we need using Ohm's Law. We need to calculate R and know V and I -> R = 3.3V/30mA = 110 Ohms. We don't have 110 Ohm resistors so used 100 instead. Our LEDs have a max current rating of 40mA and we will have a current of about 33mA with the 100 Ohm resistor."
            },
            {
              "type": "images",
              "layout": "side-by-side",
              "images": [
                {
                  "src": "img/atls3300/lab01_3v_schematic.png",
                  "caption": "3.3V LED circuit schematic",
                  "size": "small"
                },
                {
                  "src": "img/atls3300/lab01_3v_circuit.JPG",
                  "caption": "Working 3.3V LED circuit on breadboard"
                }
              ]
            },
            {
              "type": "text",
              "text": "If we wanted to use the 5V side instead we would need a larger resistor -> R = 5V/30mA = 166 Ohms. I don't have a 166 Ohm resistor so am instead using 220, this will reduce the current to about 23mA which is still in the 20-35mA range given in the lab instructions."
            },
            {
              "type": "images",
              "layout": "side-by-side",
              "images": [
                {
                  "src": "img/atls3300/lab01_5v_circuit.JPG",
                  "caption": "Working 5V LED circuit on breadboard"
                },
                {
                  "src": "img/atls3300/lab01_5v_schematic.png",
                  "caption": "5V LED circuit schematic",
                  "size": "small"
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "heading": "Part 3: Switching the LED",
          "blocks": [
            {
              "type": "text",
              "text": "In this section of the lab we added a single-pole, single-throw (SPST) momentary push button to the circuit in order to control the LED turning on and off. The LED only turns on when the button is pressed, and turns off when it's released."
            },
            {
              "type": "image",
              "src": "img/atls3300/lab01_switch_on_schematic.png",
              "caption": "Schematic for the circuit with the\nSPST push button",
              "size": "small"
            },
            {
              "type": "video",
              "src": "img/atls3300/lab01_switch_on.MOV",
              "caption": "Video of the button turning the LED on",
              "size": "medium"
            }
          ]
        },
        {
          "type": "section",
          "heading": "Part 4: Extra Volt",
          "blocks": [
            {
              "type": "text",
              "text": "The extra credit section of this lab asked us to redesign the circuit to make the LED turn off instead of on when the button is pressed. In order to do this I put the LED before the button, with its cathode connected to ground. When the button is not pressed the circuit is complete and the LED lights up, but when the button is pressed it redirects the current through the button instead and turns the LED off. This demonstrates an XOR gate, where the LED is on when the button is not pressed and off when it is. I had fun solving this but also it was really frustrating because I was being dumb and kept trying to put the button before the LED."
            },
            {
              "type": "image",
              "src": "img/atls3300/lab01_switch_off_schematic.png",
              "caption": "Schematic for the extra credit circuit",
              "size": "small"
            },
            {
              "type": "video",
              "src": "img/atls3300/lab01_switch_off.MOV",
              "caption": "Video of the button turning the LED off",
              "size": "medium"
            }
          ]
        },
        {
          "type": "section",
          "heading": "Problems Faced & Conclusion",
          "blocks": [
            {
              "type": "text",
              "text": "I didn't have any real problems through this lab. Mostly it felt like just getting used to the flow of this course and learning how to check for common circuit errors. I enjoyed wiring this stuff up and I'm excited to build more on this lab. It sorta feels like when I first started programming and you make silly mistakes on toy problems, but experiencing that helps you spot simple bugs later on."
            }
          ]
        }
      ]
    },
    {
      "id": "CSCI4239-2025-01-27-Homework-03",
      "title": "CSCI4239 Homework 3: Performance",
      "date": "2025-01-27",
      "tags": {
        "Course": ["CSCI4239", "Advanced Computer Graphics"],
        "Topic": ["OpenGL", "GLSL Shaders", "Performance"]
      },
      "content": [
        {
          "type": "section",
          "heading": "Goals",
          "note": "Written 01-27",
          "blocks": [
            {
              "type": "text",
              "text": "I've been putting off this assignment because I just haven't been sure about what I want to do for it. It's less flashy or exciting that the other assignments so far and after our discussions in class about how we'll probably be disappointed in our efforts to tank performance I wasn't super motivated to start. I'm going to start with updating the phong shading to use built-in functions max and step in order to get rid of the two if statements we have in there. I'm not sure if that'll do anything for our FPS, but I am interested in seeing if it does. I'm also going to try to make something with excessive branching and see if I can get that to tank performance, looking at ints vs floats or builtin functions vs explicit calculations seems less interesting to me past making the phong function a little more efficient. I'm going to rewrite my foggy glass shader from last week so that I can break something that already works rather than needing to work from scratch. I'll also make my scene more complex with lots of objects so that I can get a more measurable performance difference."
            }
          ]
        },
        {
          "type": "section",
          "heading": "Reflection",
          "note": "Written 01-28",
          "blocks":[
            {
              "type": "text",
              "text": "Strangely enough the updated phong shading that used max and step instead of if statements dropped my FPS by about 40 (from ~640 to ~600 when drawing 10 cubes). I think this is because the original branching version actually cuts out a bunch of calculations when the surface is facing away from the light while this new version does all of them every time. So I guess in this case the branching was actually helping us be more efficient."
            }
          ]
        }
      ],
      "assignmentDetails": "Investigate the performance of different elements of GLSL. Examples of things you may investigate is float vs. int, performance of constructs like if, select, builtin functions vs. explicit calculation, the cost of transcendental functions, inline code vs. function calls, performance differences between different video cards or operating systems, etc.\n\nWhat the program should do is left to your imagination.  The scene could involve lighting, textures, and similar features, but the assignment is to investigate performance of different ways of doing things.\n\nExample 4 contains code to calculate frames per second, which measures the overall performance.  Make sure you disable VSYNC so that this measures to true frame rate.\n\nWhat to submit:\n1) README with discussion of results and brief instructions on how to use the program;\n2) One ZIP archive containing all files you are submitting;\n3) Source code, makefile and any data files I need;\n4) Time it took you to complete the assignment."
    },
    {
      "id": "ATLS3300-2025-02-03-Lab-02",
      "title": "ATLS3300 Lab 2: Digital IO and LED Reaction Game",
      "date": "2025-02-03",
      "tags": {
        "Course": ["ATLS3300", "Object"],
        "Topic": ["Circuits", "Arduino"]
      },
      "content":[
        {
          "type": "section",
          "heading": "Description",
          "blocks": [
            {
              "type": "text",
              "text": "This lab is an introduction to Arduino, its IDE, and digital I/O. "
            },
            {
              "type": "text",
              "text": "Materials Used:\n- Arduino (Elegoo) Uno R3 Controller Board\n- USB Cable\n- Momentary Push Button (x2 for EC)\n- 830 Tie-Points Breadboard\n- Jumper Wires\n- Resistors\n- LEDs\n- Multimeter"
            }
          ]
        },
        {
          "type": "section",
          "heading": "Part 1: Setting Up the Arduino IDE",
          "blocks":[
            {
              "type":"text",
              "text": "This section of the lab was about getting ready to do the rest of the lab. We downloaded and installed Arduino IDE, connected our Arduino UNO, and selected it in the Board Selection dropdown. In order to verify everything is working we opened the Blink example program (<strong>File > Examples > 01. Basics > Blink</strong>) and uploaded it to the board."
            },
            {
              "type": "video",
              "src": "img/atls3300/lab02_blink.MOV",
              "caption": "Blink example program running on Arduino UNO R3",
              "size": "medium"
            }
          ]
        },
        {
          "type": "section",
          "heading": "Part 2: Blinking an External LED",
          "blocks":[
            {
              "type":"text",
              "text": "Now that we are all set up, we can start exploring digital output using the UNO's digital pins. The pins are binary and can be ON or OFF; HIGH or LOW; 1 or 0. HIGH and LOW correlate to a certain voltage, with HIGH being the highest voltage coming in and LOW being 0V. We can use these keywords to program the digital pins to be HIGH/LOW, turning that pin to 5V (HIGH) or 0V (LOW). We can see this is done using <code>digitalWrite(LED_BUILTIN, HIGH)</code> and <code>digitalWrite(LED_BUILTIN, LOW)</code> in the Blink example to turn the built-in LED (pin D13) on and off."
            },
            {
              "type":"text",
              "text": "Setting up the 5V LED circuit from last lab, where the LED is now powered by digital pin 10, we can use <code>digitalWrite()</code> to control this external LED. I modified the Blink example to use pin 10, stored in the constant <code>LEDPIN</code>, instead of the built-in LED."
            },
            {
              "type": "video",
              "src": "img/atls3300/lab02_blink2.MOV",
              "caption": "Blink running on external LED",
              "size": "medium"
            },
            {
              "type":"text",
              "text": "I also tried messing with the delay to see what that would look like.\n <strong>Flash warning for the following video!!</strong>"
            },
            {
              "type": "video",
              "src": "img/atls3300/lab02_blink3.MOV",
              "caption": "Blink running on external LED with only 50ms delay between states",
              "size": "medium"
            },
            {
              "type": "gist",
              "gistId": "b00kworm4lyf3/89213ecace17df3acaf8b0b1f8a983be",
              "caption": "Updated Blink, using external LED and smaller delay",
              "size":"medium"
            }
          ]
        },
        {
          "type": "section",
          "heading": "Part 3: Button Press and Serial Monitor",
          "blocks":[
            {
              "type":"text",
              "text": "Building on the previous section and the previous lab, we are now adding the push button to our circuit. In order to detect when the button is pressed, we can set up a new pin as an input pin using <code>pinMode(BUTTONPIN, INPUT)</code> in our <code>setup()</code> function, where <code>BUTTONPIN</code> is the pin number we are using for input. We can then use <code>digitalRead(BUTTONPIN)</code> to check what the current button state is - which is either HIGH or LOW, not pressed or not pressed. For this lab we want to build a circuit such that when the button is pressed <code>digitalRead(BUTTONPIN)</code> returns HIGH, and when it is not pressed we read LOW, but this could also be done the other way around."
            },
            {
              "type": "images",
              "layout": "side-by-side",
              "images": [
                {
                  "src": "img/atls3300/lab02_schematic1.png",
                  "caption": "Schematic of pressed = HIGH button"
                },
                {
                  "src": "img/atls3300/lab02_button.JPG",
                  "caption": "Implemented button with pull-down resistor"
                  
                }
              ]
            },
            {
              "type": "text",
              "text": "In order to check if we are actually detecting the button being pressed, we will print to the <strong>Serial Monitor</strong>. In the <code>setup()</code> function we call <code>Serial.begin(9600)</code> to set up a serial connection with a baud rate (data transfer speed) of 9,600 bits/second. Then in the <code>loop()</code> function we can call <code>Serial.println(\"Your message here\")</code> to print to the serial monitor."
            },
            {
              "type": "image",
              "src": "img/atls3300/lab02_print.png",
              "caption": "Message printing to serial monitor",
              "size":"medium"
            },
            {
              "type": "text",
              "text": "Now we combine the button detection with printing to the serial monitor. We want to print a waiting message when the button isn't pressed, and a success message when it is, each one only printing one time - not every time <code>loop()</code> is called. I used a check against the previous state to make sure I was only printing when the state was different than it was before. I also added a bit of an 'animation' to the print, doing a short delay between the ellipses to add to the waiting message. I played around with printing dots until the state changed again but couldn't get it smooth enough that it felt like an addition to such a simple program."
            },
            {
              "type":"gist",
              "gistId": "b00kworm4lyf3/bb1549e3980dfc4c97b763eaaa073f48",
              "caption": "Print to serial monitor when button state changes",
              "size": "medium"
            },
            {
              "type": "video",
              "src": "img/atls3300/lab02_print.mp4",
              "caption": "Demonstration of print at state change",
              "size": "medium"
            },
            {
              "type": "text",
              "text": "In the lab instructions it asks if we noticed that the button state oscillates even when just pressed once, but I didn't notice that in my program. I have a feeling it's because there's built-in debouncing (something I learned about <a href=\"https://docs.arduino.cc/built-in-examples/digital/Debounce/\" target=\"_blank\" rel=\"noopener noreferrer\">in the Arduino Docs</a>) in my program via the <code>delay()</code> calls, or maybe I just found the perfect button ┐(´ー｀)┌"
            }
          ]
        },
        {
          "type": "section",
          "heading": "Part 4: LED Reaction Game",
          "blocks":[
            {
              "type":"text",
              "text": "Time to put everyting together! In this section of the lab we make an LED reaction game. The LED connected to the Arduino will turn on after a random time interval and then the player will need to press the button as quickly as they can, with the serial monitor outputting the time it took for the player to push the button. The gameplay loop goes:\n<ol><li>The game begins with a greeting on the serial monitor.</li><li>Then the game outputs a \"Ready?\" message, to prepare the player to press the button.</li><li>After the ready message, the Arduino waits for a random interval of time between0.5s and 5s, and then turns on the LED</li><li>The player sees the LED turn on and presses the button as fast as they can</li><li>Once the button is pressed, the LED turns off and the Arduino outputs the time it took for\nthe player to press the button.</li><li>This round is over. Add a delay of 5s after each round to make the player prepared for the\nnext round. After 5s the next round begins from step 2.</li></ol>"
            },
            {
              "type": "text",
              "text": "I used <code>random(500, 5001)</code> to generate a random delay time between 500 and 5000 milliseconds. This was seeded with <code>randomSeed(8362627)</code>, a number I just mashed in I'm not sure if that matters - I'll look it up next time. Using two calls to <code>millis()</code> I was able to calculate the time it took for the button to be pressed, which I output in fractions of a second rather than milliseconds for user experience purposes. This was being rounded up a bit due to the two decimal place default, but I think that's okay for now. If I were to work on this more I would probably experiment with higher precision."
            },
            {
              "type":"gist",
              "gistId": "b00kworm4lyf3/8f2cbb18ab09ca03837164a8d51c7e3c",
              "caption": "Reaction time game with Saw inspired output"
            },
            {
              "type": "text",
              "text": "I was inspired by the Saw movies when it came to my output messages, this game seems like it could be easily modified to be one of his traps, and had a lot of fun customizing it. After a pretty generic <code>setup()</code>, the Arduino <code>loop()</code> function starts by printing my \"ready\" message - using a function I wrote called <code>timedPrint()</code> which prints character arrays one charater at a time to give textual output a typing effect. After the \"ready\" message the function <code>gameLoop()</code> is called, starting the main game outlined in steps 3-6 above. I added a few branches for different message output depending on how long the player took to press the button, I don't want to congratulate the people who took too long!"
            },
            {
              "type": "video",
              "src": "img/atls3300/lab02_game.MOV",
              "caption": "All game output branches"
            }
          ]
        },
        {
          "type":"section",
          "heading": "Part 5: Extra Volt",
          "blocks":[
            {
              "type": "text",
              "text": "A second player has arrived! For the extra credit portion of this lab we were asked to add a second button and then determine which one was pressed first during the game loop. I hooked up a second button the same way as the first one and modified my code to read both buttons, looping until one of them is pressed. I originally was also outputting how long they took to press the button, but it felt superfluous so I took that out."
            },
            {
              "type": "image",
              "src": "img/atls3300/lab02_schematic2.png",
              "caption": "Updated schematic with second button",
              "size": "medium"
            },
            {
              "type": "gist",
              "gistId": "b00kworm4lyf3/06ee63b5cf00f94ed5c9201d3802d844",
              "caption": "Updated reaction game program, now built for two players"
            },
            {
              "type": "video",
              "src": "img/atls3300/lab02_game2.MOV",
              "caption": "Two player reaction game demo"
            }
          ]
        },
        {
          "type": "section",
          "heading": "Problems Faced & Conclusion",
          "blocks":[
            {
              "type": "text",
              "text": "I didn't have any problems through this lab, everything went very smoothly. I had a lot of fun playing with serial monitor output! It reminded me of my first few programming courses and making small games that you interacted with through the console, I haven't done that in a while and it was great to revisit."
            }
          ]
        }
      ]
    }
  ]
}